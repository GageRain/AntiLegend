/*
题目：分解质因数，对于给定的一个正整数， 从小到大输出该整数的所有因子，比如
对于输入的100，输出：100=2*2*5*5 

解题思路：（假设输入的整数是number） 
整体思路：使用While循环，从小到大将number的每个因子找出来，排好序，并按照题意输出 
	
思路过程：	
（1）不同的数，可能有不同个因子，需要循环多轮，每轮寻找整数number的最小因子，
	因此是个while循环的结构。
（2） 因为有多个因子存在， 并且要排序，所以可以使用数组（不使用数组也可以，
	在寻找过程中就直接输出每个因子，并保证是从小到大输出），
	使用数组的话，将找到的每个因子保存到 数组里，最后再统一将数组排序输出
（3） 每轮while循环中寻找一个因子，对于当前轮的number，可以从2循环到number-1来找是否有因子，
	因此 需要使用一个 for循环结构，判断2至（number-1）之间是否能存在能整除number的数 
	如果寻找到第一个因子，就输出，并进入下一轮的While循环，寻找该因子之后的下一个因子。 
	因此，在当前轮的While循环中，如果找到了一个因子，则输出该因子后，将number除掉
	这个因子，也就是nubmer=number/当前因子，然后就可以进入下一轮While，这样保证下一轮
	会找到下一个新的因子。
（4） while循环的结束条件是，一轮While循环下来，没找到新的因子 ，那么当前剩下的number
	就是最后一个因子。
（5） 需要注意一个特殊情况，比如3，除了1和自身，没有其它因子，按照题意要直接输出，
	因此 可以设个变量count来记录因子的个数， 如果找到最后count仍然是零，则直接输入输入的数
（6）输出格式的问题： 对于存在多个因子的情况，第一个因子直接输出，后面的因子输入格式
	是 *因子。因此输出时，要判断当前因子是否是第一个因子，可以用一个变量如isFirst来记录。 
	
注意事项： 
  测试时 ，除了使用题里说明的例子，还要自己测试其它各种情况的例子：
  （1）1,2,3等没有其它因子的一位数
  （2）4 ，6等有其它因子的一位数
  （3）11,13等没有其它因子的2位数
  （4） 12等有其它因子的2位数
  （5） 2*3*3=18等具有多个因子并具有重复因子的数，预防重复因子出问题 
  （6） 2*3*5=30等具有多个因子，并具有不重复因子的数，预防不重复因子出问题
  （7） 再测个 2*3*5*7= 210等具有4个因子的数，基本就没问题了 
 
*/ 



#include <stdio.h>
#include <math.h>


int main()
{

	int number=0; //记录输入的整数 
	scanf("%d",&number) ;  //输入整数 
	int remember=number;   //将输入的数number备份一下，放到remember里，供后面处理时用 
	
	printf("%d=",number);    //按照题意，先输出输入的数和= 
	
	int count=0;//记录因子个数 
	int record[100];//记录因子的数组 
	
	int i;   
	int shouldCon=1;  //用于判断是否进行下一轮While循环来找下一个因子， 
	int isFirst=1;	//用于判断是否是第一个因子，用于格式控制，第一个因子直接输出，
					//第二个因子需要输出为：*因子 
	
	int haveYinzi=0;  //用于记录是否存在因子。 
	
	//一个while循环，找出一个当前最小的因子 
	while(1)  
	{
		shouldCon=0; //=0，先假设不需要下一轮While循环		
		
		//寻找最小的因子是否存在,从2开始循环到number 
		for(i=2;i<number;i++)
		{
			if(number%i==0)
			{
				shouldCon=1;  //找到了因子，则打标记 ,然后跳出该for循环，							  	
				
				record[count]=i; //将当前找到的因子记录到数组中，如果使用数组的话 
				count++; 
				
				break;   //已经找到了一个最小的因子，则不在继续找了，跳出for循环 
			}
		}		
		
		//如果前面for循环找到了因子，则输出该因子 
		if(shouldCon==1)
		{			
			//如果是第一个因子，则不输出* 
			if(isFirst==1)	
			{
				printf("%d",i);
				
				isFirst=0;  //改变 isFirst的值为0，表示后面的While循环再遇到因子，就不是第一个因子了 
			}
			else//否则，不是第一个因子，则输出*
			{
				printf("*%d",i);
			}
			
			haveYinzi=1; // 说明已经找到一个因子，至少有一个因子了，为后面的输出做准备，用于判断是否具有因子的情况 
			
			number=number/i;  //将当前找到的因子除掉，继续下一轮While循环就可以找下一个最小的因子了			
			
			continue;  //直接继续下一轮While循环 
		}
		else  //不存在其它因子了，则不需要继续找下一个因子，将结束while循环
		{	
			if(haveYinzi==1) //如果前面找到有因子 ，则输出最后的数的时候，前面加上* 
			{						
				printf("*%d",number); // 输出不再能分解的数，也就是最后一个因子							
			}
			else  //如果前面没有找到有因子 ，则输出最后的数的时候，也就是输入的数自身，前面不加*，直接输出 
			{
				printf("%d",number); // 输出不再能分解的数，也就是最后一个因子
			}
			
			record[count]=number;  //当前的number也是输入的整数的一个因子 ，也就是最后一个因子 
			count++; 
			
			break;  //不存在其它因子了，则不需要继续下一轮While循环，直接结束while循环
		}
	}
	
	
	/*可以增加排序，其实前面的从最小的2开始寻找因子的过程，已经保证是从小到大排过序了 ，	
	 也可以不用再写排序的代码， 
	*/ 
	
	// ------------------------------这是使用数组的情况下，最后统一输出的方式-----	
		
	printf("\n");
	
	printf("%d=",remember);  //按照题意，先输出输入的整数 
	
	//如果count==1，只有一个因子，也就是输入的数本身，则直接输出 
	if(count==1)
	{
		printf("%d",record[0]);  
	}
	else //如果有其它更多的因子， 则按照第一个因子，和非第一个因子开分别输出 
	{
	
		//输出所有的因子 
		for(i=0;i<count;i++)
		{
			if(i==0)  //如果是第一个因子，则直接输出该因子 
			{
				printf("%d",record[i]);
			}
			else//如果不是第一个因子，则输出格式为：*因子 
			{		
				printf("*%d",record[i]);
			}
		}
	}
	

    return 0;
} 
